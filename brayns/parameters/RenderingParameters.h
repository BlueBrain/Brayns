/* Copyright (c) 2015-2018, EPFL/Blue Brain Project
 * All rights reserved. Do not distribute without permission.
 * Responsible Author: Cyrille Favreau <cyrille.favreau@epfl.ch>
 *
 * This file is part of Brayns <https://github.com/BlueBrain/Brayns>
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 3.0 as published
 * by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef RENDERINGPARAMETERS_H
#define RENDERINGPARAMETERS_H

#include <brayns/common/types.h>

#include "AbstractParameters.h"

SERIALIZATION_ACCESS(RenderingParameters)

namespace brayns
{
class AbstractParameters;

/** Manages rendering parameters
 */
class RenderingParameters : public AbstractParameters
{
public:
    RenderingParameters();

    /** @copydoc AbstractParameters::print */
    void print() final;

    /** Engine*/
    EngineType getEngine() const { return _engine; }
    void setEngine(const EngineType name) { _updateValue(_engine, name); }
    static const std::string& getEngineAsString(const EngineType value);
    /** OSPRay modules */
    const std::vector<std::string>& getOsprayModules() const
    {
        return _modules;
    }
    /** OSPRay renderer */
    void initializeDefaultRenderers();
    RendererType getRenderer() const { return _renderer; }
    static const std::string& getRendererAsString(const RendererType value);
    void setRenderer(const RendererType renderer)
    {
        _updateValue(_renderer, renderer);
    }
    /** OSPRay supported renderers */
    static const RendererTypes& getRenderers();
    /** Shadows */
    float getShadowIntensity() const { return _shadowIntensity; }
    void setShadowIntensity(const float value)
    {
        _updateValue(_shadowIntensity, value);
    }
    /** Softs Shadows generated by randomizing light source position */
    float getSoftShadows() const { return _softShadows; }
    void setSoftShadows(const float value)
    {
        _updateValue(_softShadows, value);
    }
    /** Ambient occlusion */
    float getAmbientOcclusionStrength() const
    {
        return _ambientOcclusionStrength;
    }
    void setAmbientOcclusionStrength(const float value)
    {
        _updateValue(_ambientOcclusionStrength, value);
    }
    float getAmbientOcclusionDistance() const
    {
        return _ambientOcclusionDistance;
    }
    void setAmbientOcclusionDistance(const float value)
    {
        _updateValue(_ambientOcclusionDistance, value);
    }

    /** Shading applied to the geometry
     */
    ShadingType getShading() const { return _shading; }
    static const std::string& getShadingAsString(const ShadingType value);
    void setShading(const ShadingType value) { _updateValue(_shading, value); }
    /** Number of samples per pixel */
    int getSamplesPerPixel() const { return _spp; }
    void setSamplesPerPixel(const int value) { _updateValue(_spp, value); }
    /** Enables photon emission according to the radiance value of the
     * material */
    bool getLightEmittingMaterials() const { return _lightEmittingMaterials; }
    void setLightEmittingMaterials(const bool value)
    {
        _updateValue(_lightEmittingMaterials, value);
    }

    bool getDynamicLoadBalancer() const { return _dynamicLoadBalancer; }
    void setDynamicLoadBalancer(const bool value)
    {
        _updateValue(_dynamicLoadBalancer, value);
    }

    const Vector3f& getBackgroundColor() const { return _backgroundColor; }
    void setBackgroundColor(const Vector3f& value)
    {
        _updateValue(_backgroundColor, value);
    }
    /**
       Defines the maximum distance between intersection and surrounding
       geometry for touch detection rendering
    */
    float getDetectionDistance() const { return _detectionDistance; }
    void setDetectionDistance(const float value)
    {
        _updateValue(_detectionDistance, value);
    }
    /**
       Defines if touch detection applies if the material of the surrounding
       geometry is different from the one of the intersection
    */
    bool getDetectionOnDifferentMaterial() const
    {
        return _detectionOnDifferentMaterial;
    }
    void setDetectionOnDifferentMaterial(const bool value)
    {
        _updateValue(_detectionOnDifferentMaterial, value);
    }

    /**
       Near color used by touch detection renderer
    */
    const Vector3f& getDetectionNearColor() const
    {
        return _detectionNearColor;
    }
    void setDetectionNearColor(const Vector3f& value)
    {
        _updateValue(_detectionNearColor, value);
    }

    /**
       Far color used by touch detection renderer
    */
    const Vector3f& getDetectionFarColor() const { return _detectionFarColor; }
    void setDetectionFarColor(const Vector3f& value)
    {
        _updateValue(_detectionFarColor, value);
    }

    /**
       Camera type
    */
    CameraType getCameraType() const { return _cameraType; }
    StereoMode getStereoMode() const { return _stereoMode; }

    static const std::string& getCameraTypeAsString(const CameraType value);
    static const std::string& getStereoModeAsString(const StereoMode value);

    /**
       Light source follow camera origin
    */
    bool getHeadLight() const { return _headLight; }
    /** If the rendering should be refined by accumulating multiple passes */
    bool getAccumulation() const { return _accumulation; }
    /**
     * @return the threshold where accumulation stops if the variance error
     * reaches this value.
     */
    float getVarianceThreshold() const { return _varianceThreshold; }
    /**
     * The threshold where accumulation stops if the variance error reaches this
     * value.
     */
    void setVarianceThreshold(const float value)
    {
        _updateValue(_varianceThreshold, value);
    }

    /**
     * The maximum number of accumulation frames before engine signals to stop
     * continuation of rendering.
     *
     * @sa Engine::continueRendering()
     */
    void setMaxAccumFrames(const size_t value)
    {
        _updateValue(_maxAccumFrames, value);
    }
    size_t getMaxAccumFrames() const { return _maxAccumFrames; }
    /**
     * @brief Defines the number of samples per ray for ray-casting rendering
     * (typically volumes)
     * @param spr Number of samples per ray
     */
    void setSamplesPerRay(const size_t spr) { _updateValue(_spr, spr); }
    size_t getSamplesPerRay() const { return _spr; }

    static void parseDefaults(const po::variables_map& vm);
    static void resetDefaultCamera();
    static void resetDefaultRenderer();

    void parse(const po::variables_map& vm) final;

protected:

    EngineType _engine{EngineType::ospray};
    std::vector<std::string> _modules;
    RendererType _renderer{RendererType::default_};
    CameraType _cameraType{CameraType::default_};
    StereoMode _stereoMode{StereoMode::none};
    float _ambientOcclusionStrength{0.f};
    float _ambientOcclusionDistance{1e6f};
    ShadingType _shading{ShadingType::diffuse};
    bool _lightEmittingMaterials{false};
    int _spp{1};
    bool _accumulation{true};
    float _shadowIntensity{0.f};
    float _softShadows{0.f};
    Vector3f _backgroundColor{0.f, 0.f, 0.f};
    float _detectionDistance{1.f};
    bool _detectionOnDifferentMaterial{true};
    Vector3f _detectionNearColor{1.f, 0.f, 0.f};
    Vector3f _detectionFarColor{0.f, 1.f, 0.f};
    bool _headLight{false};
    bool _dynamicLoadBalancer{false};
    float _varianceThreshold{-1.f};
    size_t _maxAccumFrames{100};
    size_t _spr{128};

    SERIALIZATION_FRIEND(RenderingParameters)
};
}
#endif // RENDERINGPARAMETERS_H
