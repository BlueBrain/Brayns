/* Copyright (c) 2015-2017, EPFL/Blue Brain Project
 * All rights reserved. Do not distribute without permission.
 * Responsible Author: Cyrille Favreau <cyrille.favreau@epfl.ch>
 *
 * Based on OSPRay implementation
 *
 * This file is part of Brayns <https://github.com/BlueBrain/Brayns>
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 3.0 as published
 * by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

// Brayns
#include <plugins/engines/ospray/ispc/render/utils/AbstractRenderer.ih>

// needs to be the same in MorphologyLoader.cpp
uniform const uniform float OFFSET_MAGIC = 1e6;

struct SimulationRenderer
{
    AbstractRenderer abstract;

    int randomNumber;

    float shadows;
    float softShadows;
    float ambientOcclusionStrength;
    float ambientOcclusionDistance;
    bool shadingEnabled;
    bool electronShadingEnabled;

    uint32 volumeSamplesPerRay;

    // Transfer function / Color map attributes
    uniform vec4f* uniform colorMap;
    uniform vec3f* uniform emissionIntensitiesMap;
    uint32 colorMapSize;
    float colorMapMinValue;
    float colorMapRange;

    Model* simulationModel;
    uniform float* uniform simulationData;
    uint64 simulationDataSize;
    float threshold;
    float detectionDistance;
};

struct ShadingAttributes
{
    const uniform SimulationRenderer* uniform self;
    varying DifferentialGeometry* dg;
    vec3f origin;
    vec3f normal;
    vec3f reflectedNormal;
    float refraction;
    float reflection;
    float opacity;
    vec3f diffuseColor;
    vec3f specularColor;
    float specularExponent;
    vec3f lightEmissionColor;
    float lightEmissionIntensity;
    bool castSimulationData;
    vec4f simulationColor;
    vec3f indirectColor;
    float indirectIntensity;
    vec3f volumeColor;
    float volumeIntensity;
    vec3f shadingContribution;
    vec3f finalContribution;
};

inline vec3f refractedVector(const varying vec3f& direction,
                             const varying vec3f& normal,
                             const varying float n1, const varying float n2)
{
    if (n2 == 0.f)
        return direction;
    const float eta = n1 / n2;
    const float cos1 = -dot(direction, normal);
    const float cos2 = 1.f - eta * eta * (1.f - cos1 * cos1);
    if (cos2 > 0.f)
        return eta * direction + (eta * cos1 - sqrt(cos2)) * normal;
    return direction;
}

inline void composite(const varying vec4f& src, varying vec4f& dst,
                      const varying float alphaCorrection)
{
    const float alpha =
        1.f - pow(1.f - min(src.w, 1.f - 1.f / 256.f), alphaCorrection);
    const float a = alpha * (1.f - dst.w);
    dst.x = dst.x + src.x * a;
    dst.y = dst.y + src.y * a;
    dst.z = dst.z + src.z * a;
    dst.w += (alpha * (1.f - dst.w));
}

inline float shadedLightIntensity(
    const uniform SimulationRenderer* uniform self,
    varying ScreenSample& sample, const varying vec3f& intersection,
    const varying vec3f& normal, const varying vec3f& lightDirection,
    const varying float epsilon)
{
    vec3f ld = lightDirection;
    if (self->softShadows != 0.f)
        // Slightly alter light direction for Soft shadows
        ld = normalize(ld +
                       self->softShadows *
                           getRandomVector(sample, normal, self->randomNumber));

    Ray shadowRay;
    setRay(shadowRay, intersection, ld);
    shadowRay.t0 = epsilon;
    shadowRay.time = sample.ray.time;
    shadowRay.t = infinity;

    varying float opacity = 0.f;
    varying float intensity = 1.f;
    varying int depth = 0;
    varying bool moreRebounds = true;

#if 0
    // Light attenuation altered by volume
    // TO BE DONE?
    if (self->volumeData)
    {
        const vec4f volumetricValue =
            getVolumeContribution(self, shadowRay, sample,
                                  self->volumeSamplesPerRay);
        intensity = volumetricValue.w;
        moreRebounds = (intensity > 0.f);
    }
#endif

    while (moreRebounds && depth < NB_MAX_REBOUNDS)
    {
        traceRay(self->abstract.super.model, shadowRay);

        if (shadowRay.geomID >= 0)
        {
            DifferentialGeometry dg;
            postIntersect(self->abstract.super.model, dg, shadowRay,
                          DG_MATERIALID | DG_TEXCOORD | DG_COLOR);

            uniform ExtendedOBJMaterial* objMaterial =
                (uniform ExtendedOBJMaterial*)dg.material;

            varying float materialOpacity = 1.f;

            if (objMaterial == 0)
                materialOpacity = 1.f - dg.color.w;
            else
            {
                foreach_unique(mat in objMaterial)
                {
                    materialOpacity = mat->d;
                    if (valid(mat->map_d))
                    {
                        vec4f d_map = get4f(mat->map_d, dg.st);
                        materialOpacity = d_map.x;
                    }
                    else if (valid(mat->map_Kd))
                    {
                        vec4f localDiffuseColor_map = get4f(mat->map_Kd, dg.st);
                        materialOpacity = 1.f - localDiffuseColor_map.w;
                    }
                }
            }

            opacity += materialOpacity;
            intensity -= materialOpacity * self->shadows;

            if (intensity < ALPHA_THRESHOLD || opacity >= 1.f)
                moreRebounds = false;

            shadowRay.t0 = shadowRay.t + dg.epsilon;
            shadowRay.t = infinity;
            shadowRay.primID = -1;
            shadowRay.geomID = -1;
            shadowRay.instID = -1;
            ++depth;
        }
        else
            moreRebounds = false;
    }
    return intensity;
}

// AABB-Ray intersection ( http://prideout.net/blog/?p=64 ).
inline varying bool intersectBox(const uniform SimulationRenderer* uniform self,
                                 const varying Ray& ray, const vec3f& aabbMin,
                                 const vec3f& aabbMax, varying float& t0,
                                 varying float& t1)
{
    const float epsilon = 0.0001f;
    Ray r = ray;
    // We need to avoid division by zero in "vec3 invR = 1.0 / r.Dir;"
    if (r.dir.x == 0)
        r.dir.x = epsilon;

    if (r.dir.y == 0)
        r.dir.y = epsilon;

    if (r.dir.z == 0)
        r.dir.z = epsilon;

    vec3f invR = 1.f / r.dir;
    vec3f tbot = invR * (aabbMin - r.org);
    vec3f ttop = invR * (aabbMax - r.org);
    vec3f tmin = min(ttop, tbot);
    vec3f tmax = max(ttop, tbot);
    vec2f t = make_vec2f(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
    t0 = max(t.x, t.y);
    t = make_vec2f(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
    t1 = min(t.x, t.y);
    return (t0 <= t1);
}

inline varying float getVolumeShadowContribution(
    const uniform SimulationRenderer* uniform self, const varying Ray& ray,
    varying ScreenSample& sample)
{
    //    // Find volume intersections
    //    float t0, t1;
    //    vec3f aabbMin = self->volumeOffset;
    //    vec3f aabbMax =
    //        make_vec3f(self->volumeOffset) +
    //        make_vec3f(self->volumeDimensions) * self->volumeElementSpacing;
    //    if (!intersectBox(self, ray, aabbMin, aabbMax, t0, t1))
    //        return 0.f;

    //    // Ray marching from light source to voxel
    //    const float epsilon = max(0.01f, (t1 - t0) /
    //    self->volumeSamplesPerRay);
    //    const vec3i dimensions = self->volumeDimensions;
    //    const float random = getRandomValue(sample, self->randomNumber) *
    //    epsilon;
    float shadowIntensity = 0.f;
    //    for (float t = t1 - random; t > epsilon && shadowIntensity < 1.f;
    //         t -= epsilon)
    //    {
    //        vec3f point = ray.org + ray.dir * t;

    //        if (point.x >= 0.f && point.x < dimensions.x && point.y >= 0.f &&
    //            point.y < dimensions.y && point.z >= 0.f && point.z <
    //            dimensions.z)
    //        {
    //            uint64 index = (uint64)(
    //                (uint64)floor(point.x) + (uint64)floor(point.y) *
    //                dimensions.x +
    //                (uint64)floor(point.z) * dimensions.x * dimensions.y);

    //            const uint8 voxelValue = self->volumeData[index];

    //            const float normalizedValue =
    //                self->colorMapSize * (voxelValue - self->colorMapMinValue)
    //                /
    //                self->colorMapRange;
    //            const vec4f colorMapColor = self->colorMap[normalizedValue];
    //            shadowIntensity += colorMapColor.w;
    //        }
    //    }
    return shadowIntensity;
}

inline varying vec4f getVolumeContribution(
    Volume* uniform volume, const uniform SimulationRenderer* uniform self,
    const varying Ray& ray, varying ScreenSample& sample)
{
    //    if (!self->colorMap)
    //        return make_vec4f(0.f, 1.f, 0.f, 0.f);

    // Find volume intersections
    float t0, t1;
    //    vec3f aabbMin = self->volumeOffset;
    //    vec3f aabbMax =
    //        make_vec3f(self->volumeOffset) +
    //        make_vec3f(self->volumeDimensions) * self->volumeElementSpacing;
    intersectBox(ray, volume->boundingBox, t0, t1);
    // return make_vec4f(0.f, 0.f, 0.f, 0.f);

    // Ray marching
    vec4f pathColor = make_vec4f(0.f);
    const float epsilon = max(0.01f, (t1 - t0) / self->volumeSamplesPerRay);
    const float random = getRandomValue(sample, self->randomNumber) * epsilon;
    t0 -= random;
    t1 -= random;
    for (float t = t0; t < t1 && pathColor.w < 1.f; t += epsilon)
    {
        //        const vec3f point = ((ray.org + ray.dir * t) -
        //        self->volumeOffset) /
        //                            self->volumeElementSpacing;
        const vec3f point = ray.org + t * ray.dir;

        //        if (point.x >= 0.f && point.x < self->volumeDimensions.x &&
        //            point.y >= 0.f && point.y < self->volumeDimensions.y &&
        //            point.z >= 0.f && point.z < self->volumeDimensions.z)
        {
            const float sample = volume->sample(volume, point);

            // Look up the color associated with the volume sample.
            vec3f sampleColor = volume->transferFunction->getColorForValue(
                volume->transferFunction, sample);

            // Look up the opacity associated with the volume sample.
            const float sampleOpacity =
                volume->transferFunction->getOpacityForValue(
                    volume->transferFunction, sample);

            //            const uint64 index =
            //                (uint64)((uint64)floor(point.x) +
            //                         (uint64)floor(point.y) *
            //                         self->volumeDimensions.x +
            //                         (uint64)floor(point.z) *
            //                         self->volumeDimensions.x *
            //                             self->volumeDimensions.y);

            //            const uint8 voxelValue = self->volumeData[index];

            //            const float normalizedValue =
            //                (voxelValue - self->colorMapMinValue) /
            //                self->colorMapRange;

            //            // Voxel color and opacity
            //            vec4f colorMapColor;
            //            if (normalizedValue < 0.f)
            //                colorMapColor = self->colorMap[0];
            //            else if (normalizedValue > 1.f)
            //                colorMapColor = self->colorMap[self->colorMapSize
            //                - 1];
            //            else
            //                colorMapColor =
            //                    self->colorMap[self->colorMapSize *
            //                    normalizedValue];

            //            // Light emission intensity
            //            const vec4f emissionIntensity =
            //                make_vec4f(self->emissionIntensitiesMap[normalizedValue],
            //                0.f);
            //            vec4f voxelColor =
            //                max(make_vec4f(0.f), emissionIntensity +
            //                colorMapColor);

            //            // Shadow intensity
            //            float shadowIntensity = 0.f;
            //            vec4f giContribution = make_vec4f(0.f);
            //            if (self->shadows > 0.f && voxelColor.w > 0.01f)
            //            {
            //                // Determine global illumination contribution
            //                for (uniform int i = 0; self->lights && i <
            //                self->numLights;
            //                     ++i)
            //                {
            //                    const uniform Light* uniform light =
            //                    self->lights[i];
            //                    const varying vec2f s =
            //                        make_vec2f(1.f / self->randomNumber);
            //                    DifferentialGeometry dg;
            //                    dg.P = point;
            //                    const varying Light_SampleRes lightSample =
            //                        light->sample(light, dg, s);

            //                    Ray lightRay = ray;
            //                    if (self->softShadows > 0.f)
            //                        lightRay.dir = normalize(
            //                            lightSample.dir +
            //                            self->softShadows *
            //                                getRandomVector(sample,
            //                                lightSample.dir,
            //                                                self->randomNumber));
            //                    else
            //                        lightRay.dir = lightSample.dir;

            //                    lightRay.t =
            //                    length(make_vec3f(self->volumeDimensions));
            //                    lightRay.t0 = dg.epsilon;
            //                    lightRay.org = point;
            //                    lightRay.dir = lightSample.dir;

            //                    shadowIntensity +=
            //                        getVolumeShadowContribution(self,
            //                        lightRay, sample);
            //                }
            //                const float giAttenuation =
            //                    1.f - shadowIntensity * self->shadows;
            //                voxelColor.x = voxelColor.x * giAttenuation;
            //                voxelColor.y = voxelColor.y * giAttenuation;
            //                voxelColor.z = voxelColor.z * giAttenuation;
            //            }

            // Compose final voxel color
            vec4f voxelColor =
                clamp(sampleOpacity / volume->samplingRate) *
                make_vec4f(sampleColor.x, sampleColor.y, sampleColor.z, 1.0f);
            composite(voxelColor, pathColor, (float)self->volumeSamplesPerRay);
        }
    }
    return make_vec4f(min(1.f, pathColor.x), min(1.f, pathColor.y),
                      min(1.f, pathColor.z), min(1.f, pathColor.w));
}

inline bool launchRandomRay(const uniform SimulationRenderer* uniform self,
                            varying ScreenSample& sample,
                            const varying vec3f& intersection,
                            const varying vec3f& normal,
                            DifferentialGeometry& geometry,
                            varying vec3f& backgroundColor,
                            varying float& distanceToIntersection,
                            varying vec3f& randomDirection)
{
    randomDirection = getRandomVector(sample, normal, self->randomNumber);
    backgroundColor = make_vec3f(0.f);

    if (dot(randomDirection, normal) < 0.f)
        // Invert direction of random ray direction is opposite to surface
        // normal
        randomDirection = neg(randomDirection);

    varying Ray randomRay = sample.ray;
    setRay(randomRay, intersection, randomDirection);
    randomRay.t0 = geometry.epsilon;
    randomRay.t = self->ambientOcclusionDistance;
    randomRay.primID = -1;
    randomRay.geomID = -1;
    randomRay.instID = -1;

    traceRay(self->abstract.super.model, randomRay);
    if (randomRay.geomID < 0)
    {
        // No intersection
        backgroundColor = make_vec3f(skyboxMapping((Renderer*)self, randomRay,
                                                   self->abstract.bgMaterial));
        return false;
    }

    // Random ray hits a primitive
    distanceToIntersection = randomRay.t * randomRay.t;
    postIntersect(self->abstract.super.model, geometry, randomRay,
                  DG_NG | DG_NS | DG_NORMALIZE | DG_MATERIALID | DG_COLOR |
                      DG_TEXCOORD);
    return true;
}

inline void indirectShading(const uniform SimulationRenderer* uniform self,
                            varying ScreenSample& sample,
                            const varying vec3f& intersection,
                            const varying vec3f& normal,
                            DifferentialGeometry& geometry,
                            varying vec3f& indirectShadingColor,
                            varying float& indirectShadingPower)
{
    vec3f backgroundColor;
    float distanceToIntersection = infinity;
    indirectShadingPower = 0.f;

    // Launch a random ray
    vec3f randomDirection;
    if (launchRandomRay(self, sample, intersection, normal, geometry,
                        backgroundColor, distanceToIntersection,
                        randomDirection))
    {
        // Determine material of intersected geometry
        const uniform Material* material = geometry.material;
        const uniform ExtendedOBJMaterial* objMaterial =
            (const uniform ExtendedOBJMaterial*)material;
        if (objMaterial)
            foreach_unique(mat in objMaterial)
            {
                // Check if material emits light and is random rays hits the
                // surface in the opposite direction from the surface normal
                if (mat->a != 0.f && dot(geometry.Ns, randomDirection) < 0.f)
                {
                    // Light emitting material
                    vec3f localDiffuseColor = mat->Kd;
                    if (valid(mat->map_Kd))
                        localDiffuseColor = get3f(mat->map_Kd, geometry.st);

                    // intensity
                    vec3f Ka = make_vec3f(mat->a);
                    indirectShadingPower = mat->a;
                    if (valid(mat->map_a))
                    {
                        Ka = get3f(mat->map_a, geometry.st);
                        indirectShadingPower = reduce_max(Ka);
                    }

                    // Returned color is the one material with weight according
                    // intensity and distance to intersection
                    indirectShadingColor = localDiffuseColor * Ka;
                    indirectShadingPower = 1.f / distanceToIntersection;
                }
                else
                {
                    // Material does not emit light, occlusion is considered
                    // according to surface localOpacity
                    indirectShadingColor = make_vec3f(1.f);
                    indirectShadingPower = -mat->d;
                }
            }
        else
        {
            // Material does not emit light, occlusion is considered
            // according to surface localOpacity
            indirectShadingColor = make_vec3f(geometry.color.w);
            indirectShadingPower = -geometry.color.w;
        }

        indirectShadingPower *= abs(dot(normal, randomDirection));
    }
    else
    {
        indirectShadingColor = backgroundColor;
        indirectShadingPower = DEFAULT_SKY_POWER;
    }
    indirectShadingPower *= self->ambientOcclusionStrength;
}

inline void initializeShadingAttributes(
    const uniform SimulationRenderer* uniform self,
    ShadingAttributes& attributes)
{
    attributes.self = self;
    attributes.dg = 0;

    // Final contribution
    attributes.finalContribution = make_vec3f(0.f);

    // Simulation contribution
    attributes.castSimulationData = true;
    attributes.simulationColor = make_vec4f(0.f);

    // Indirect light contribution
    attributes.indirectColor = make_vec3f(0.f);
    attributes.indirectIntensity = 0.f;

    // Light emission
    attributes.lightEmissionColor = make_vec3f(0.f);
    attributes.lightEmissionIntensity = 0.f;

    // Volume
    attributes.volumeColor = make_vec3f(0.f);
    attributes.volumeIntensity = 0.f;

    // Specular color
    attributes.specularColor = make_vec3f(0.f);
    attributes.specularExponent = 0.f;

    // Shading contribution
    attributes.shadingContribution = make_vec3f(0.f);

    // Other attributes
    attributes.reflection = 0.f;
    attributes.refraction = 1.f;
    attributes.opacity = 0.f;
}

inline void setGeometryShadingAttributes(
    const uniform SimulationRenderer* uniform self, DifferentialGeometry& dg,
    varying ScreenSample& sample, Ray& ray, ShadingAttributes& attributes)
{
    attributes.dg = &dg;

    // Intersection point with geometry
    attributes.origin = dg.P;

    // Shading normal
    attributes.normal = dg.Ns;

    // Reflected shading normal
    attributes.reflectedNormal =
        ray.dir - 2.f * dot(ray.dir, attributes.normal) * attributes.normal;

    // Process material attributes
    const uniform Material* material = dg.material;
    const uniform ExtendedOBJMaterial* objMaterial =
        (const uniform ExtendedOBJMaterial*)material;
    if (!objMaterial)
    {
        // Diffuse color
        attributes.diffuseColor = make_vec3f(dg.color);

        // if no material is defined, localOpacity is stored in the alpha
        // component of the RGBA color
        attributes.opacity = dg.color.w;
        return;
    }

    foreach_unique(mat in objMaterial)
    {
        // Glossiness
        if (mat->glossiness < 1.f)
        {
            const vec3f randomNormal =
                (1.f - mat->glossiness) *
                getRandomVector(sample, attributes.normal, self->randomNumber);
            attributes.normal = normalize(attributes.normal + randomNormal);
        }

        // Refraction index
        attributes.refraction = mat->refraction;

        // Opacity
        if (valid(mat->map_d))
            attributes.opacity = mat->d * get1f(mat->map_d, dg.st);
        else
            attributes.opacity = mat->d;

        // Diffuse color
        attributes.diffuseColor = mat->Kd * make_vec3f(dg.color);
        if (valid(mat->map_Kd))
        {
            const vec4f diffuseColorFromMap = get4f(mat->map_Kd, dg.st);
            attributes.diffuseColor =
                attributes.diffuseColor * make_vec3f(diffuseColorFromMap);
            attributes.opacity *= diffuseColorFromMap.w;
        }

        // Specular color
        if (valid(mat->map_Ks))
            attributes.specularColor = max(attributes.specularColor,
                                           mat->Ks * get3f(mat->map_Ks, dg.st));
        else
            attributes.specularColor = max(attributes.specularColor, mat->Ks);

        // Specular exponent
        if (valid(mat->map_Ns))
            attributes.specularExponent =
                max(attributes.specularExponent,
                    mat->Ns * get1f(mat->map_Ns, dg.st));
        else
            attributes.specularExponent =
                max(attributes.specularExponent, mat->Ns);

        // Light emission intensity
        attributes.lightEmissionIntensity += mat->a;
        attributes.lightEmissionColor = attributes.diffuseColor;

        // Normal mapping
        if (valid(mat->map_Bump))
        {
            const vec3f n = get3f(mat->map_Bump, dg.st, make_vec3f(0.f)) - 0.5f;
            attributes.normal.x -= n.x;
            attributes.normal.y -= n.y;
        }

        // Reflection index
        attributes.reflection = mat->reflection;
        if (valid(mat->map_reflection))
        {
            const vec3f value = get3f(mat->map_reflection, dg.st);
            attributes.reflection *= (value.x + value.y + value.z) / 3.f;
        }

        // Cast simulation data
        attributes.castSimulationData = mat->castSimulationData;
    }

    // Update reflected shading normal
    attributes.reflectedNormal =
        ray.dir - 2.f * dot(ray.dir, attributes.normal) * attributes.normal;
}

/**
  The processSimulationContribution reads simulation value
  from the simulation data buffer.
  The geometry contains the offset of the buffer in it's X texture coordinates.
  The value from the simulation data buffer is then converted into a color,
  according to the colormap.
  */
inline void processSimulationValue(ShadingAttributes& attributes,
                                   varying DifferentialGeometry* dg)
{
    float value = 0.f;
    const uint64 index = (uint64)(dg->st.x * OFFSET_MAGIC) << 32 |
                         (uint32)(dg->st.y * OFFSET_MAGIC);

    if (index < attributes.self->simulationDataSize)
        value = attributes.self->simulationData[index];
    else
        // Value offset is out of range, return error color
        return;

    if (value < attributes.self->threshold)
        return;

    // Normalize the value according colormap size
    const float normalizedValue = (value - attributes.self->colorMapMinValue) /
                                  attributes.self->colorMapRange;

    const uint32 lookupIndex = max(0.f, min(normalizedValue, 1.f)) *
                               (attributes.self->colorMapSize - 1);

    attributes.simulationColor = attributes.self->colorMap[lookupIndex];

    if (attributes.self->emissionIntensitiesMap)
        attributes.lightEmissionColor =
            attributes.lightEmissionColor +
            attributes.self->emissionIntensitiesMap[lookupIndex];
}

/**
  The purpose of the processSimulationContribution function is to retrieve the
  value of the simulation from a secondary model attached to the OSPRay scene.
  The geometry is defined by the primary model, but the shading is computed
  according to a second, non-visible model that contains the simulation values.
  In the case of circuit rendering for examples, neurons are meshes, and
  compartment reports are cones and cylinders that are inside the neuron. When
  an intersection is found at the surface of a mesh, a ray defined by the
  intersection point and the opposite normal to the surface is launched to hit
  the secondary model. When the secondary model is intersected, the simulation
  value is retrieved and used to shade the surface of the mesh.
*/
inline void processSimulationContribution(varying ScreenSample& sample,
                                          ShadingAttributes& attributes,
                                          const int materialID)
{
    if (!attributes.castSimulationData)
        return;

    if (!attributes.self->simulationModel)
    {
        processSimulationValue(attributes, attributes.dg);
        return;
    }

    // Get simulation color from simulation model
    Ray colorRay;
    colorRay.org = attributes.origin;
    colorRay.dir = getRandomVector(sample, attributes.normal * -1.f,
                                   attributes.self->randomNumber);
    colorRay.t0 = 0.f;
    colorRay.time = inf;
    colorRay.t = attributes.self->detectionDistance;
    colorRay.primID = -1;
    colorRay.geomID = -1;
    colorRay.instID = -1;

    // Trace ray to hit the simulation model
    traceRay(attributes.self->simulationModel, colorRay);

    if (colorRay.geomID < 0)
        attributes.simulationColor = make_vec4f(0.f);
    else
    {
        // Intersection found. Simulation ray hit a primitive
        varying DifferentialGeometry colorDg;
        postIntersect(attributes.self->simulationModel, colorDg, colorRay,
                      DG_MATERIALID | DG_TEXCOORD);
        if (materialID == colorDg.materialID && attributes.self->simulationData)
            // The mesh and it's corresponding representation in the
            // simulation model must use the same material ID. This is to
            // make sure that one neuron is not shaded with the simulation
            // value of another neuron.
            processSimulationValue(attributes, &colorDg);
    }
}

inline void processBackgroundColor(varying ScreenSample& sample, Ray& ray,
                                   ShadingAttributes& attributes)
{
    // No intersection. Return volume contribution + skybox color
    const vec4f bgColor = skyboxMapping((Renderer*)attributes.self, ray,
                                        attributes.self->abstract.bgMaterial);

    attributes.shadingContribution = make_vec3f(bgColor);
    attributes.opacity = 1.f;
}

inline void computeIndirectShading(DifferentialGeometry& dg,
                                   varying ScreenSample& sample,
                                   ShadingAttributes& attributes)

{
    if (attributes.self->ambientOcclusionStrength < 0.01f)
        return;

    indirectShading(attributes.self, sample, attributes.origin,
                    attributes.normal, dg, attributes.indirectColor,
                    attributes.indirectIntensity);
}

inline void processLightShading(DifferentialGeometry& dg,
                                varying ScreenSample& sample,
                                ShadingAttributes& attributes)
{
    if (!attributes.self->abstract.lights)
    {
        attributes.shadingContribution = attributes.diffuseColor;
        return;
    }

    // Shading for all lights defined in the scene
    attributes.shadingContribution = make_vec3f(0.f);
    for (uniform int i = 0; i < attributes.self->abstract.numLights; ++i)
    {
        const uniform Light* uniform light =
            attributes.self->abstract.lights[i];
        const vec2f s = make_vec2f(0.5f);
        const varying Light_SampleRes lightSample = light->sample(light, dg, s);
        const float radiance = reduce_max(lightSample.weight);
        const vec3f lightDirection = lightSample.dir;

        if (radiance > 0.f)
        {
            float cosNL = 1.f;

            const bool shadingEnabled = attributes.self->shadingEnabled;
            if (shadingEnabled)
            {
                // Phong + Blinn shading
                cosNL = max(0.f, dot(lightDirection, attributes.normal));

                // Specular color
                const float cosLR =
                    dot(lightDirection, attributes.reflectedNormal);
                attributes.specularColor =
                    attributes.specularColor *
                    powf(cosLR, attributes.specularExponent);
            }
            else
                attributes.specularColor = make_vec3f(0.f);

            attributes.diffuseColor = cosNL * attributes.diffuseColor;

            // Process shadows
            const bool shadowsEnabled =
                attributes.self->shadows > 0.f &&
                attributes.lightEmissionIntensity < 0.01f;
            const float alpha =
                shadowsEnabled
                    ? shadedLightIntensity(attributes.self, sample,
                                           attributes.origin, attributes.normal,
                                           lightDirection, dg.epsilon)
                    : 1.f;
            attributes.shadingContribution =
                attributes.shadingContribution +
                radiance * alpha * attributes.diffuseColor;

            if (alpha < 1.f)
                attributes.specularColor = make_vec3f(0.f);
        }
    }
}

inline void processElectronShading(varying ScreenSample& sample,
                                   ShadingAttributes& attributes)
{
    const vec3f viewer = normalize(sample.ray.org - attributes.origin);
    const float el = max(0.f, dot(viewer, attributes.normal));
    const float cosNL = 1.f - el;
    attributes.shadingContribution = attributes.diffuseColor * cosNL;
    attributes.specularColor = make_vec3f(0.f);
}

inline void processVolumeContribution(varying ScreenSample& sample,
                                      ShadingAttributes& attributes, Ray& ray)
{
    // if (attributes.self->abstract.volumeData)
    for (uniform int32 i = 0;
         i < attributes.self->abstract.super.model->volumeCount; i++)
    {
        Volume* uniform volume_i =
            attributes.self->abstract.super.model->volumes[i];
        const vec4f volumetricValue =
            getVolumeContribution(volume_i, attributes.self, ray, sample);
        attributes.volumeColor = make_vec3f(volumetricValue);
        attributes.volumeIntensity = volumetricValue.w;
        break;
    }
}

inline void processFinalContribution(ShadingAttributes& attributes)
{
    // Indirect light contribution
    const vec3f indirectContribution = attributes.opacity *
                                       attributes.indirectColor *
                                       attributes.indirectIntensity;

    // Simulation contribution
    const vec3f simulationColor = make_vec3f(attributes.simulationColor);
    float alpha = attributes.simulationColor.w;

    // Surface shading + volume final contribution
    vec3f totalContributions =
        (attributes.shadingContribution + simulationColor) * (1.f - alpha) +
        attributes.shadingContribution * simulationColor * alpha +
        indirectContribution;

    // Specular contribution
    totalContributions = totalContributions + attributes.specularColor;

    // Light emission contribution
    totalContributions =
        make_vec3f(totalContributions) +
        attributes.lightEmissionIntensity * attributes.lightEmissionColor;

    // Volume contribution
    if (attributes.volumeIntensity > 0.f)
    {
        vec4f dst =
            make_vec4f(totalContributions, 1.f - attributes.volumeIntensity);
        const vec4f src =
            make_vec4f(attributes.volumeColor, attributes.volumeIntensity);
        composite(src, dst, attributes.self->volumeSamplesPerRay);
        totalContributions = make_vec3f(dst);
    }

    // Store final contribution
    attributes.finalContribution =
        clamp(totalContributions, make_vec3f(0.f), make_vec3f(1.f));
}

inline vec3f SimulationRenderer_shadeRay(
    const uniform SimulationRenderer* uniform self,
    varying ScreenSample& sample)
{
    Ray ray = sample.ray;
    vec3f color = make_vec3f(0.f);

    unsigned int depth = 0;
    float oldlocalRefraction = 1.f;
    bool moreRebounds = true;
    float pathOpacity = 1.f;
    float totalOpacity = 0.f;

    sample.z = inf;
    sample.alpha = 0.f;

    while (moreRebounds && depth < NB_MAX_REBOUNDS && pathOpacity > 0.f)
    {
        // Shading attributes store all color contributions for the current ray
        ShadingAttributes attributes;
        initializeShadingAttributes(self, attributes);

        // Trace ray
        traceRay(self->abstract.super.model, ray);

        float epsilon = 0.f;

        if (ray.geomID < 0)
        {
            // Background contribution
            processBackgroundColor(sample, ray, attributes);

            // Volume contribution
            processVolumeContribution(sample, attributes, ray);

            // No Geometry intersection. No need to iterate more
            moreRebounds = false;

            if (depth == 0)
                totalOpacity = 0.f;
        }
        else
        {
            // Get intersection information
            DifferentialGeometry dg;
            postIntersect(self->abstract.super.model, dg, ray,
                          DG_NG | DG_NS | DG_NORMALIZE | DG_FACEFORWARD |
                              DG_TANGENTS | DG_MATERIALID | DG_COLOR |
                              DG_TEXCOORD);

            // Initialize geometry shading attributes
            setGeometryShadingAttributes(self, dg, sample, ray, attributes);

            // Compute simulation contribution
            processSimulationContribution(sample, attributes, dg.materialID);

            // Z-Depth
            if (depth == 0)
                sample.z = ray.t;

            if (attributes.opacity > 0.01f && moreRebounds)
            {
                // Compute indirect lighting contribution
                computeIndirectShading(dg, sample, attributes);

                // Compute surface shading
                if (self->electronShadingEnabled)
                    processElectronShading(sample, attributes);
                else
                    processLightShading(dg, sample, attributes);

                // Compute volume contribution
                processVolumeContribution(sample, attributes, ray);
            }
            else
                // Fully transparent object. Ignore intersection
                ray.t0 = ray.t + 1.f;

            // Alpha
            totalOpacity += attributes.opacity;

            epsilon = dg.epsilon;
        }

        // Combine all contributions
        processFinalContribution(attributes);

        // Pixel Color
        color = attributes.finalContribution * pathOpacity +
                color * (1.f - pathOpacity);

        // Prepare ray for next iteration
        bool doRefraction = (attributes.opacity < 1.f);
        bool doReflection = (attributes.reflection > 0.f);
        if (doRefraction && doReflection)
        {
            // Switch between refraction and reflection
            const bool reflect = sample.sampleID.z % 4 == 1;
            doRefraction = !reflect;
            doReflection = reflect;
        }

        ray.org = attributes.origin;
        ray.t0 = epsilon;
        ray.t = inf;
        ray.primID = -1;
        ray.geomID = -1;
        ray.instID = -1;

        if (doRefraction)
        {
            // Refraction
            ray.dir =
                refractedVector(ray.dir, attributes.normal, oldlocalRefraction,
                                attributes.refraction);
            pathOpacity *= 1.f - attributes.opacity;
            oldlocalRefraction = attributes.refraction;
        }
        else if (doReflection)
        {
            // Reflection
            ray.dir = attributes.reflectedNormal;
            pathOpacity *= attributes.reflection;
        }
        else
            moreRebounds = false;

        ++depth;
    }

    sample.alpha = min(1.f, totalOpacity);
    return color;
}

void SimulationRenderer_renderSample(uniform Renderer* uniform _self,
                                     void* uniform perFrameData,
                                     varying ScreenSample& sample)
{
    uniform SimulationRenderer* uniform self =
        (uniform SimulationRenderer * uniform)_self;
    sample.ray.time = infinity;
    sample.rgb = SimulationRenderer_shadeRay(self, sample);
}

// Exports (called from C++)
export void* uniform SimulationRenderer_create(void* uniform cppE)
{
    uniform SimulationRenderer* uniform self =
        uniform new uniform SimulationRenderer;
    Renderer_Constructor(&self->abstract.super, cppE);
    self->abstract.super.renderSample = SimulationRenderer_renderSample;
    return self;
}

export void SimulationRenderer_set(
    void* uniform _self, void* uniform simulationModel,
    void* uniform bgMaterial, const uniform float& shadows,
    const uniform float& softShadows,
    const uniform float& ambientOcclusionStrength,
    const uniform float& ambientOcclusionDistance,
    const uniform bool& shadingEnabled, const uniform int& randomNumber,
    const uniform float& timestamp, const uniform int& spp,
    const uniform bool& electronShadingEnabled, void** uniform lights,
    const uniform int32 numLights, const uniform int32& volumeSamplesPerRay,
    uniform float* uniform simulationData,
    const uniform uint64& simulationDataSize, uniform vec4f* uniform colormap,
    uniform vec3f* uniform emissionIntensitiesMap,
    const uniform int32 colorMapSize, const uniform float& colorMapMinValue,
    const uniform float& colorMapRange, const uniform float& threshold,
    const uniform float& detectionDistance)
{
    uniform SimulationRenderer* uniform self =
        (uniform SimulationRenderer * uniform)_self;

    self->abstract.super.spp = spp;
    self->abstract.bgMaterial =
        (uniform ExtendedOBJMaterial * uniform)bgMaterial;
    self->abstract.lights = (const uniform Light* uniform* uniform)lights;
    self->abstract.numLights = numLights;
    self->abstract.timestamp = timestamp;

    self->shadows = shadows;
    self->softShadows = softShadows;
    self->ambientOcclusionStrength = ambientOcclusionStrength;
    self->ambientOcclusionDistance = ambientOcclusionDistance;
    self->shadingEnabled = shadingEnabled;
    self->randomNumber = randomNumber;
    self->electronShadingEnabled = electronShadingEnabled;

    self->volumeSamplesPerRay = volumeSamplesPerRay;

    self->colorMap = (uniform vec4f * uniform)colormap;
    self->emissionIntensitiesMap =
        (uniform vec3f * uniform)emissionIntensitiesMap;
    self->colorMapSize = colorMapSize;
    self->colorMapMinValue = colorMapMinValue;
    self->colorMapRange = colorMapRange;

    self->simulationModel = (uniform Model * uniform)simulationModel;
    self->simulationData = (uniform float* uniform)simulationData;
    self->simulationDataSize = simulationDataSize;

    self->threshold = threshold;
    self->detectionDistance = detectionDistance;
}
